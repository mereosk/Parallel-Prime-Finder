ΠΑΝΕΠΙΣΤΗΜΙΟ ΑΘΗΝΩΝ
Τμήμα Πληροφορικής και Τηλεπικοινωνιών 
2η Εργασία - Τμήμα: Περιττών Αριθμών Μητρώου
Κ22 Λειτουργικά Συστήματα – Χειμερινό Εξάμηνο ΄20
Κωνσταντίνος Μερεός  sdi1700085


________________



Διαμόρφωση και διαδικαστικά:
Το πρόγραμμά μου είναι χωρισμένο σε διαφορετικά modules, συγκεκριμένα στα include, modules και programs. Ο φάκελος programs περιέχει τα πηγαία προγράμματα, τα οποία διαμορφώνουν και το νοητό δέντρο το οποίο προσδιορίζει η εργασία. Δηλαδή μέσα σε αυτόν περιέχονται το myprime.c το οποίο είναι η ρίζα του προγράμματος, το οποίο καλεί κάποια intermediates τα οποία βρίσκονται μέσα στο inter.c και αυτά με τη σειρά τους καλούν κάποιους workers, prime1.c, prime2.c και prime3.c. Επίσης στον φάκελο modules έχω υλοποιήσει τις λειτουργίες μιας ταξινομημένης λίστας στο αρχείο ADTBList.c, καθώς και την υλοποίηση κάποιων βασικών συναρτήσεων, που χρειάζονται πολλά αρχεία κώδικα, με το όνομα func.c. Τα προηγούμενα 2 αρχικοποιούνται στον φάκελο include, αλλά εκτός τις αρχικοποιήσεις των προγραμμάτων,περιέχει και ένα αρχείο common_types.h, το οποίο περιέχει διάφορα typedefs. Τέλος υλοποίησα και ένα Makefile το οποίο βρίσκεται μέσα στον φάκελο programs και έχει τις εξείς λειτουργίες. Τρέχοντας την εντολή “make” παράγονται τα εκτελέσιμα προγράμματα. Μία σκιαγράφηση αυτού φαίνεται παρακάτω:


~@~:~/Documents/operSystems/project2/programs$ make
gcc -Wall  -g -I../include   -c -o myprime.o myprime.c
gcc myprime.o ../modules/ADTBList.o ../modules/func.o -o myprime
gcc -Wall  -g -I../include   -c -o inter.o inter.c
gcc inter.o ../modules/ADTBList.o ../modules/func.o -o inter
gcc -Wall  -g -I../include   -c -o prime1.o prime1.c
gcc prime1.o ../modules/func.o -o prime1
gcc -Wall  -g -I../include   -c -o prime2.o prime2.c
gcc prime2.o ../modules/func.o -o prime2 -lm
gcc -Wall  -g -I../include   -c -o prime3.o prime3.c
gcc prime3.o ../modules/func.o -o prime3 -lm


Επιπροσθέτως δίνεται η επιλογή στον χρήστη να τρέξει το πρόγραμμα με την εντολή “make run”, με την οποία θα τρέξει το πρόγραμμα με τα εξείς arguments (τα οποία ορίζονται στο Makefile) : “-l 50 -u 100 -w 3”. Μπορείτε να τα αλλάξετε στο Makefile->ARGS Τέλος δίνεται η δυνατότητα με την εντολή “make clean” να διαγραφούν όλα τα αντικειμενικά και εκτελέσιμα αρχεία.


Workers:
Ξεκινώντας από κάτω προς τα πάνω την ανάλυσή της δενδρικής δομής, υλοποιώ τους workers prime1.c, prime2.c και prime3.c. Σε αυτούς παρέχεται ένα διάστημα και καλούνται να βρουν όλους τους πρώτους αριθμούς που βρίσκονται μέσα σε αυτό. Τα φύλλα, όπως λέγονται και αλλιώς, χρησιμοποιούν έναν από τρεις αλγορίθμους primes. Οι workers πρέπει να βρίσκουν έναν πρώτο αριθμό και να τον στείλουν, μαζί με το χρόνο που χρειάστηκε να τον βρει, στον πατέρα-intermediate κόμβο. Αυτό το υλοποιώ, και στέλνω μια δομή struct details στην οποία τοποθετώ τις δύο τιμές που περιέγραψα πιο πριν. Πριν τελειώσει όμως ο συγκεκριμένος worker και επιστρέψει στέλνει και τον ολικό χρόνο που χρειάστηκε για να ολοκληρώσει την διαδικασία. Για να στείλω αυτόν τον χρόνο, πάλι στέλνω μία δομή η οποία αντί για τον prime θα έχει την τιμή 0, ώστε να γίνεται αντιληπτό από τον πατέρα ότι η τιμή που ακολουθεί το 0 είναι ο ολικός χρόνος που έκανε το φύλλο να τελειώσει. Όλες αυτές τις τιμές τις γράφει μία μία στο pipe που έχει δημιουργήσει ο intermediate κόμβος και έχει περάσει την τιμή του file descriptor σαν όρισμα στην γραμμή εντολών. Πριν τελειώσουν τα παιδιά στέλνουν ένα σήμα SIGUSR1 μέσω του syscall kill στη ρίζα, της οποίας το id είναι γνωστό πάλι από τον πατέρα intermediate με τη διαδικασία που περιέγραψα πιο πριν. Φυσικά δεν ξεχνάω να κλείσω τον fd, τη στιγμή που τελειώσω το γράψιμο.


Όσον αφορά τους αλγόριθμους, ο πρώτος, ο δεύτερος και η μέτρηση χρόνου, είναι αυτοί που μας δόθηκαν με λίγες παραμετροποιήσεις για να δουλεύουν στα δεδομένα μου. Ο τρίτος αλγόριθμος prime ακολουθεί τη λογική του κόσκινου του ερατοσθένη με λίγες διαφορές. Συγκεκριμένα, η λογική είναι ότι βλέπω αρχικά αν ο αριθμός διαιρείται ακριβώς με το δύο και το τρία. Αν δεν ισχύει το προηγούμενο, εκτελώ μια επανάληψη από το πέντε με βήμα έξι. Σε αυτό το διάστημα οι μόνοι υποψήφιοι διαιρέτες του αριθμού βρίσκονται στην πρώτη και στην τρίτη θέση αυτής της εξάδας. Αυτό συμβαίνει, διότι ανά εξάδες, αρχίζοντας από περιττό αριθμό, θα συναντήσω τρεις ζυγούς (δεν διαιρείται με το 2), οπότε δεν χρειάζεται να δοκιμάσω τον δεύτερο, τέταρτο και έκτο αριθμό. Στη συνέχεια μια εξάδα θα περιέχει οπωσδήποτε δύο πολλαπλάσια του τρία, αλλά το ένα συμπίπτει με ένα πολλαπλάσιο του 2, οπότε στο προκείμενο παράδειγμα δεν χρειάζεται να ελέγξουμε ούτε τον πέμπτο αριθμό.
	


Intermediates:
Για την υλοποίηση των intermediate (inter.c) αποφάσισα να χρησιμοποιήσω ένα μόνο αρχείο καθώς δεν αλλάζει τίποτα ανάμεσά τους. Αρχικά, οι εσωτερικοί κόμβοι παίρνουν μέσω της γραμμής εντολής, κάποια όρια διαστήματος. Συγκεκριμένα πόσα παιδιά πρέπει να δημιουργήσουν, ένα fd με το οποίο πρέπει να περάσουν στο τέλος τα αποτελέσματά τους στο pipe με το οποίο επικοινωνούν με τη ρίζα, αλλά και τον αριθμό που έχουν σαν Intermediate. Ο προηγούμενος αριθμός fd είναι, μόνο, για το pipe επικοινωνίας ρίζας-εσωτερικού κόμβου. Άρα φτιάχνω και ένα pipe για κάθε παιδί που πρόκειται να αποκτήσει ο intermediate με τη βοήθεια ενός πίνακα με file descriptors. Μετά σπάω το διάστημα και άλλο σύμφωνα με τη συνάρτηση generate ranges (την αναλύω πιο μετά). Στη συνέχεια μέσω μιας επανάληψης εκτελώ τα απαραίτητα forks για να δημιουργήσω τους workers. Πριν όμως εκτελέσω την exec για να τρέξουν οι αλγόριθμοι των φύλλων και να υπολογιστούν οι πρώτοι αριθμοί πρέπει να κάνω κάποια πράγματα. Απαραίτητο είναι να κλείσω όλα τα fd’s που δεν χρειάζονται από τον δηλαδή να κρατήσω μόνο τον fd[WRITE] του συγκεκριμένου παιδιού. Επειδή έχω στη διάθεσή μου μόνο τρεις αλγορίθμους για την αναζήτηση πρώτων αριθμών, τους χρησιμοποιώ κυκλικά. Τέλος αφού μετατρέψω τα όρια διαστήματος, το fd αλλά και το id της λίστας σε συμβολοσειρές καλώ την prime με τα παραπάνω ορίσματα στη γραμμή εντολής.


Η επόμενη λειτουργία των intermediates είναι να διαβάζουν τα δεδομένα από τα pipes μεταξύ αυτών και των workers, να τα συλλέγουν σε μια ταξινομημένη λίστα και να τα περνάνε με τη σειρά τους μέσω του pipe root-intermediate στο myprime. Για να πετύχω αυτή τη λειτουργία μετά την επανάληψη με τις fork και exec, τσεκάρω αν είμαι στον intermediate (μέσω childpid > 0). Μέσω επανάληψης κλείνω όλα τα fd’s που αφορούν το γράψιμο. Στη συνέχεια εκτελώ άλλη μια επανάληψη σε όλα τα παιδιά και για το καθένα, διαβάζω μέσω του pipe όλους τους πρώτους αριθμούς με τους χρόνους τους. Περιμένω, όμως, να διαβάσω και κάποια 0, συγκεκριμένα όσα είναι τα παιδιά. Αυτό, όπως περιέγραψα και πιο πάνω, δείχνει ότι ο αριθμός είναι απλά ένας συμβολισμός και αυτό που με ενδιαφέρει είναι ο χρόνος, ο οποίος είναι το time που έκανε το συγκεκριμένο παιδί να ολοκληρώση όλη τη διαδικασία. Αυτό πρέπει να το εισάγω στη λίστα και να το στείλω στη ρίζα, το πρόβλημα όμως είναι ότι πρέπει κάπως να συμβολίσω ότι ο χρόνος αυτός είναι του i’th παιδιού, ώστε να εκτυπώσει η ρίζα:
printf("Time for W%d: %lf msecs\n", i, “time”);
Για να το υλοποιήσω αυτό εκμεταλλεύομαι τη μεταβλητή numOfInter, το οποίο είναι ο αριθμός του εσωτερικού κόμβου (μου το παρέχει η ρίζα). Εφόσον λοιπόν έχω και τον αριθμό του παιδιού (αφού τρέχω μέσα σε ένα for και το i είναι ο αριθμός του παιδιού) κάνω την πράξη  και περνάω στην λίστα τον αντίθετο του. Αν παραδείγματος χάριν πήρα τον αριθμό του παιδιού 1 στην λίστα θα περάσω το struct {-1, time}. Σε αυτήν την περίπτωση, θεωρώ ότι οι αρνητικοί αριθμοί δεν μπορούν να είναι πρώτοι και τους χρησιμοποιώ σαν συμβολισμούς (μια μεγάλη κουβέντα ανάμεσα σε μαθηματικούς από ότι είδα στο web). Έτσι με μια απλή αλλαγή ενός {-x, time}θα αναγνωρίσει η ρίζα ότι:
1. O χρόνος αυτός είναι ο ολικός, αφού ο αριθμός είναι αρνητικός και
2. Ο χρόνος αυτός είναι του Χ παιδιού.
Τέλος εκτελώ μια επανάληψη της λίστας και περνάω όλα τα struct ένα προς ένα μέσα στο pipe του οποίου το fd το ξέρω από τη γραμμή εντολών.


Root:
Το myprime.c είναι το κυρίως πρόγραμμα. Οι λειτουργίες του προηγούμενου δεν διαφέρουν κατά πολύ από το inter.c που περιέγραψα παραπάνω. Θα αναλύσω, λοιπόν, περισσότερο λειτουργίες που δεν είχαν οι intermediate. Αρχικά κάνει handle την είσοδο μέσω της γραμμής εντολών, προσέχοντας ότι όλες οι σημαίες είναι εκεί, και έχοντας την δυνατότητα να αναγνωρίσει τα ορίσματα και ας είναι ανακατεμένα. Ορίζει έναν στατικό πίνακα workers με μέγεθος όσο τα φύλλα του δέντρου, ο οποίος θα πάρει τους ολικούς χρόνους που έκανε ένα prime.c να τελειώσει. Στη συνέχεια χωρίζει διαστήματα, φτιάχνει pipes, κάνει forks και execs, περνώντας τα κατάλληλα ορίσματα στους intermediate (όλα αυτά τα περιέγραψα ενδελεχώς πιο πάνω). Μετά διαβάζει πάλι από τα pipes και εισάγει κάθε struct που έρχεται, μέσα στη λίστα που έχει αρχικοποιήσει πιο πριν. Τρέχω, εν τέλει, όλη τη λίστα και υπάρχουν δύο εκδοχές:
1. Αν ο αριθμός είναι θετικός, τότε είναι ο prime και άρα εκτελώ μία απλή εκτύπωση.
2. Αν είναι αρνητικός, τότε ο αντίθετος αριθμός είναι ένας δείκτης του παιδιού (πχ W0,W1..) και ο χρόνος είναι ο ολικός που έκανε το παιδί να τελειώσει όλη τη διαδικασία. Οπότε βάζω στην κατάλληλη θέση του πίνακα workers (μέσω του αριθμού), το χρόνο.
Τέλος κάνω απλές εκτυπώσεις που ορίζει η εργασία προσέχοντας να αλλάζω το χρόνο από seconds σε milliseconds.


Κάθε φορά που τελειώνει ένα φύλλο τη διαδικασία του στέλνει ένα σήμα SIGUSR1 μέσω του syscall kill. Η άσκηση μας λέει να εκτυπώσουμε πόσα σήματα ήρθαν στη ρίζα. Για αυτό το λόγο έχω ορίσει μια εξωτερική μεταβλητή numUSR1rec, και μία συνάρτηση για να κάνει handle το συγκεκριμένο σήμα handle_sigusr1(). Έτσι, μέσα στη main έχω την εντολή:
signal(SIGUSR1, handle_sigusr1);
με την οποία κάθε φορά που έρχεται ένα σήμα SIGUSR1, εκτελείται η συνάρτηση και αυξάνεται κατά ένα η μεταβλητή numUSR1rec.



Ταξινομημένη λίστα:
Εδώ παραθέτω τη δομή που έχω υλοποιήσει. Δεν μπαίνω πολύ σε βάθος όσο αφορά τις συναρτήσεις, διότι θα ξεφύγει σε έκταση το έγγραφο. Ελπίζω τα σχόλια που έβαλα στο πρόγραμμα να είναι κατατοπιστικά. Να αναφέρω επίσης, ότι έχω εμπνευστεί αρκετά στην παρακάτω υλοποίηση από το μάθημα Δομές Δεδομένων και Τεχνικές Προγραμματισμού (Τμήμα Περιττών ΑΜ K08).
Η δομή που υλοποίησα είναι η abstract ταξινομημένη αμφίδρομη λίστα ADTBList. Η δομή αυτή είναι υλοποιημένη έτσι ώστε να μπορεί να δεχτεί ότι δεδομένο θέλουμε είτε αυτό είναι ένας ακέραιος είτε μία άλλη δομή ακόμα. Συγκεκριμένα στο πρόβλημά μου η compare που χρησιμοποιήθηκε για να είναι η λίστα ταξινομημένη συγκρίνει δύο struct Details και η υλοποίηση της έγινε στο func.c. Εν συνεχεία, είναι υλοποιημένη με διπλά συνδεδεμένες λίστες και το πέρασμά της είναι γραμμικό. Μία ιδιαιτερότητα που την διαχωρίζει από μία απλή λίστα είναι το γεγονός ότι μπορείς να πας από έναν κόμβο και στις δύο κατευθύνσεις. Σε λίγο πιο τεχνικά θέματα, η ADTBList αποτελείται από δύο επιμέρους δομές τη λίστα και τον κόμβο. Ο κόμβος έχει απλά δύο δείκτες στον προηγούμενο και στον επόμενο κόμβο καθώς και την τιμή σε Pointer (void *).
Το κεντρικό struct list έχει μία συνάρτηση καταστροφής την οποία ορίζει ο χρήστης καθώς και το size ώστε να μην χρειάζεται O(n) πολυπλοκότητα για να βρω το μέγεθός της. Επιπροσθέτως έχει έναν δείκτη σε struct list_node στον τελευταίο κόμβο αλλά και έναν κόμβο dummy ώστε ακόμα και μια empty list να έχει έναν κόμβο, αυτό απλοποιεί πολλές λειτουργίες. Όπως προανέφερα χρησιμοποιεί μια συνάρτηση compare η οποία εκτός από το να βρίσκει ένα κόμβο (list_find), χρησιμοποιείται για να εισαχθεί το αντικείμενο στη σωστή θέση (list_ordered_insert).Πέρα από τα παραπάνω τα σχόλια στις αρχικοποιήσεις των συναρτήσεων στον include φάκελο έχουν λεπτομέρειες για κάθε συνάρτηση. Η κύρια υλοποίηση της λίστας βρίσκεται στα modules και συγκεκριμένα /ADTBList.c .


Χωρισμός διαστημάτων:
Για την υλοποίηση της συνάρτησης generate_ranges, με την οποία χωρίζω το διάστημα σε “numOfChildren” ίσα μέρη με βοήθησαν πολύ απαντήσεις στο site https://stackexchange.com/.  Αρχικά ορίζω έναν στατικό πίνακα ranges, με μέγεθος όσο το numOfChildren, ο οποίος θα περιέχει struct Range, η οποία δομή περιέχει δύο ακεραίους που ορίζουν τα όρια του διαστήματος κάθε παιδιού. Στη συνέχεια καλώ τη συνάρτηση η οποία, στην αρχή, ορίζει πάλι έναν στατικό πίνακα με μέγεθος όσα τα παιδιά, ο οποίος θα περιέχει το διάστημα που θα έχει κάθε παιδί. Μετά αρχικοποιώ το μέγεθος του κάθε bucket του πίνακα με το μεγαλύτερο δυνατό μήκος εκτελώντας την ακέραια διαίρεση του  (lb + ub +1)/numOfChildren. Ότι απομένει ως υπόλοιπο το διαμοιράζω όσο το δυνατόν πιο δίκαια σε κάθε bucket. Τώρα που ξέρω το μέγεθος κάθε bucket μπορώ να ορίσω στον πίνακα ranges τα διαστήματα. Την generate_ranges την χρησιμοποιούν και το πρόγραμμα myprime.c αλλά και τα inter.c.


Κατακλείδα:
Τέλος θα ήθελα να προσθέσω ότι το readme αναπτύχθηκε στα google docs.


Ευχαριστώ πολύ για το χρόνο και την υπομονή σας.
